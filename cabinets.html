<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Visual Cabinet Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: sans-serif;
        }
        #layout {
            width: 100%;
            height: 1000px;
            border: 2px dashed #ccc;
            position: relative;
            margin-bottom: 20px;
            background-color: #f8fafc;
        }
        .cabinet {
            position: absolute;
            border: 2px solid #444;
            background-color: rgba(100, 150, 240, 0.3);
            padding: 4px;
            text-align: center;
            font-size: 10px;
            cursor: move;
        }
        .delete-button {
            display: inline-block;
            margin-top: 4px;
            padding: 2px 4px;
            background-color: #dc2626;
            color: white;
            font-size: 10px;
            border-radius: 3px;
            cursor: pointer;
        }
    </style>
</head>
<body class="p-6">
<h2 class="text-xl font-bold mb-4">Visual Cabinet Planner</h2>

<div class="flex gap-4 mb-4">
    <button onclick="showForm()" class="px-4 py-2 bg-blue-600 text-white rounded">Add Cabinet</button>
    <button onclick="downloadCSV()" class="px-4 py-2 bg-green-600 text-white rounded">Download CSV</button>
</div>

<div id="layout"></div>

<!-- Modal -->
<div id="form" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden">
    <div class="bg-white p-6 rounded shadow-md w-full max-w-sm">
        <h3 class="text-lg font-semibold mb-4">Add Cabinet</h3>
        <div class="space-y-2">
            <label class="block">Width (cm): <input type="number" id="cabWidth" class="border p-1 w-full" required></label>
            <label class="block">Height (cm): <input type="number" id="cabHeight" class="border p-1 w-full" required></label>
            <label class="block">Depth (cm): <input type="number" id="cabDepth" class="border p-1 w-full" required></label>
            <label class="block">Thickness (mm): <input type="number" id="cabThickness" value="18" class="border p-1 w-full" required></label>
            <label class="block">Type:
                <select id="cabType" class="border p-1 w-full" onchange="toggleCabinetTypeOptions()">
                    <option value="door">Door</option>
                    <option value="drawer">Drawer</option>
                </select>
            </label>

            <div id="doorOptions">
                <label class="block">Doors:
                    <input type="number" id="cabDoors" value="2" class="border p-1 w-full">
                </label>
            </div>

            <div id="drawerOptions" class="hidden space-y-2">
                <label class="block">Drawers:
                    <input type="number" id="cabDrawers" value="3" class="border p-1 w-full">
                </label>
                <label class="block">Heights (comma-separated %):
                    <input type="text" id="drawerHeights" value="30,30,40" class="border p-1 w-full" placeholder="e.g. 30,30,40">
                </label>
                <label class="block">Slider Clearance (mm per side):
                    <input type="number" id="drawerClearance" value="12" class="border p-1 w-full">
                </label>
            </div>

            <div class="flex justify-end gap-2 pt-2">
                <button onclick="hideForm()" class="px-3 py-1 bg-gray-400 text-white rounded">Cancel</button>
                <button onclick="addCabinet()" class="px-3 py-1 bg-blue-600 text-white rounded">Add</button>
            </div>
        </div>
    </div>
</div>

<script>
    const layout = document.getElementById("layout");
    const cabinets = [];
    let counter = 1;

    function showForm() {
        document.getElementById("form").classList.remove("hidden");
    }

    function hideForm() {
        document.getElementById("form").classList.add("hidden");
    }

    function toggleCabinetTypeOptions() {
        const type = document.getElementById("cabType").value;
        document.getElementById("doorOptions").classList.toggle("hidden", type !== "door");
        document.getElementById("drawerOptions").classList.toggle("hidden", type !== "drawer");
    }

    function removeCabinet(id) {
        cabinets.forEach((cab, index) => {
            if (cab.id === id) {
                cabinets.splice(index, 1);
                const div = document.getElementById(id);
                div.remove();
                return;
            }
        });
    }

    function dragElement(elmnt) {
        let offsetX, offsetY;
        elmnt.onmousedown = function (e) {
            if (e.target.classList.contains("delete-button")) return;
            e.preventDefault();
            offsetX = e.clientX - elmnt.offsetLeft;
            offsetY = e.clientY - elmnt.offsetTop;
            document.onmouseup = stopDrag;
            document.onmousemove = drag;
        };

        function drag(e) {
            e.preventDefault();
            const x = e.clientX - offsetX;
            const y = e.clientY - offsetY;
            elmnt.style.left = x + "px";
            elmnt.style.top = y + "px";
        }

        function stopDrag() {
            document.onmouseup = null;
            document.onmousemove = null;

            let finalLeft = Math.round(elmnt.offsetLeft / 10) * 10;
            let finalTop = Math.round(elmnt.offsetTop / 10) * 10;

            const otherBoxes = Array.from(document.getElementsByClassName("cabinet")).filter(el => el !== elmnt);

            let rect1 = {
                x: finalLeft,
                y: finalTop,
                w: elmnt.offsetWidth,
                h: elmnt.offsetHeight
            };

            let collision = false;
            let bestSnap = null;

            for (let other of otherBoxes) {
                const rect2 = {
                    x: other.offsetLeft,
                    y: other.offsetTop,
                    w: other.offsetWidth,
                    h: other.offsetHeight
                };

                if (
                    rect1.x < rect2.x + rect2.w &&
                    rect1.x + rect1.w > rect2.x &&
                    rect1.y < rect2.y + rect2.h &&
                    rect1.y + rect1.h > rect2.y
                ) {
                    collision = true;

                    const snapOptions = [
                        [rect2.x - rect1.w, rect2.y],
                        [rect2.x + rect2.w, rect2.y],
                        [rect2.x, rect2.y - rect1.h],
                        [rect2.x, rect2.y + rect2.h],
                        [rect2.x, rect2.y]
                    ];

                    for (let [snapX, snapY] of snapOptions) {
                        snapX = Math.round(snapX / 10) * 10;
                        snapY = Math.round(snapY / 10) * 10;
                        const testRect = {
                            x: snapX,
                            y: snapY,
                            w: rect1.w,
                            h: rect1.h
                        };

                        const overlap = otherBoxes.some(other2 => {
                            if (other2 === other) return false;
                            const r = {
                                x: other2.offsetLeft,
                                y: other2.offsetTop,
                                w: other2.offsetWidth,
                                h: other2.offsetHeight
                            };
                            return (
                                testRect.x < r.x + r.w &&
                                testRect.x + testRect.w > r.x &&
                                testRect.y < r.y + r.h &&
                                testRect.y + testRect.h > r.y
                            );
                        });

                        if (!overlap) {
                            bestSnap = [snapX, snapY];
                            break;
                        }
                    }
                    break;
                }
            }

            if (!collision || bestSnap === null) {
                elmnt.style.left = finalLeft + "px";
                elmnt.style.top = finalTop + "px";
            } else {
                elmnt.style.left = bestSnap[0] + "px";
                elmnt.style.top = bestSnap[1] + "px";
            }
        }
    }
    function addCabinet() {
        const w = parseFloat(document.getElementById("cabWidth").value);
        const h = parseFloat(document.getElementById("cabHeight").value);
        const d = parseFloat(document.getElementById("cabDepth").value);
        const t = parseFloat(document.getElementById("cabThickness").value);
        const type = document.getElementById("cabType").value;

        if (!w || !h || !d || !t) return;

        const id = `CAB-${counter++}`;
        const cab = { id, w: w * 10, h: h * 10, d: d * 10, t, type };

        if (type === "door") {
            cab.doors = parseInt(document.getElementById("cabDoors").value) || 0;
        } else if (type === "drawer") {
            cab.drawers = parseInt(document.getElementById("cabDrawers").value) || 0;
            cab.heights = document.getElementById("drawerHeights").value.split(",").map(s => parseFloat(s.trim())).filter(v => !isNaN(v));
            cab.clearance = parseFloat(document.getElementById("drawerClearance").value) || 0;

            const total = cab.heights.reduce((a, b) => a + b, 0);
            if (cab.heights.length !== cab.drawers || total !== 100) {
                alert("Drawer proportions must match drawer count and sum to 100%.");
                return;
            }
        }

        cabinets.push(cab);

        const div = document.createElement("div");
        div.className = "cabinet";
        div.id = id;
        div.style.width = `${w * 2}px`;
        div.style.height = `${h * 2}px`;
        div.style.left = `${Math.random() * 400}px`;
        div.style.top = `${Math.random() * 400}px`;
        let content = `${id}<br>${w}x${h}x${d}<br>`;
        if (type === "door" && cab.doors > 0) {
            content += `üö™ ${cab.doors} door(s)`;
        } else if (type === "drawer") {
            content += `üóÑÔ∏è ${cab.drawers} drawer(s)<br>${cab.heights.join("% / ")}`;
        }
        div.innerHTML = content;

        const deleteBtn = document.createElement("div");
        deleteBtn.className = "delete-button";
        deleteBtn.textContent = "Delete";
        deleteBtn.onclick = () => removeCabinet(id);
        div.appendChild(deleteBtn);

        layout.appendChild(div);
        dragElement(div);
        hideForm();
    }

    function downloadCSV() {
        const panels = [];
        cabinets.forEach(cab => {
            const { id: prefix, w: width, h: height, d: depth, t, type } = cab;

            panels.push([height, depth, 2, 1, 0, 0, 1, `${prefix}- Side panel`, ""]);
            panels.push([width - 2 * t, depth, 2, 1, 1, 0, 0, `${prefix}- Top/Bottom panel`, ""]);
            panels.push([width - 2 * t, height - 2 * t, 1, 0, 0, 0, 0, `${prefix}- Back panel`, ""]);

            if (type === "door" && cab.doors > 0) {
                const totalReveal = (cab.doors === 1) ? 4 : 6;
                const dw = (width - totalReveal) / cab.doors;
                const dh = height - 4;
                const hinge = dh > dw ? "duza strana" : "kraca strana";
                for (let i = 0; i < cab.doors; i++) {
                    panels.push([dh, dw, 1, 1, 1, 1, 1, `${prefix}- Door`, hinge]);
                }
            }

            if (type === "drawer" && cab.drawers > 0 && Array.isArray(cab.heights)) {
                const usableHeight = height - ((cab.drawers + 1) * 2);
                const drawerWidth = width - 2 * t;
                const drawerDepth = depth - t;
                const clr = cab.clearance || 0;
                let cumulativeY = 2;
                for (let i = 0; i < cab.drawers; i++) {
                    const pct = cab.heights[i] / 100;
                    const faceHeight = Math.round(pct * usableHeight);
                    const internalHeight = faceHeight - 4;
                    const innerW = drawerWidth - 2 * clr;
                    const innerD = drawerDepth;

                    panels.push([faceHeight, drawerWidth, 1, 1, 1, 1, 1, `${prefix}- Drawer ${i + 1} Face`, ""]);
                    panels.push([internalHeight, innerD, 2, 1, 0, 0, 1, `${prefix}- Drawer ${i + 1} Side`, ""]);
                    panels.push([internalHeight, innerD, 1, 0, 0, 0, 0, `${prefix}- Drawer ${i + 1} Back`, ""]);
                    panels.push([innerW, innerD, 1, 0, 0, 0, 0, `${prefix}- Drawer ${i + 1} Bottom`, ""]);

                    cumulativeY += faceHeight + 2;
                }
            }
        });

        let csv = "1. dimension (mm),2. dimension (mm),quantity,edge banding right,edge banding left,edge banding bottom,edge banding top,label,hinge location\n";
        panels.forEach(p => {
            csv += p.join(",") + "\n";
        });

        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "cabinet_panels.csv";
        a.click();
    }
</script>

</body>
</html>







